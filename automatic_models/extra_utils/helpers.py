"""General helpers for video processing"""
import math
import cv2
import numpy as np
import matplotlib.pyplot as plt
from typing import Tuple, Optional, List, Dict
from pathlib import Path
from matplotlib.patches import Rectangle
from matplotlib.collections import PatchCollection


def divide_video_into_frames(video_path: str,
                             output_folder: str,
                             save_raw_frames: bool = False,
                             desired_frequency: Optional[int] = None) -> List:
    """
    Divide video file into images with desired frequency rate
    :param video_path: path to video
    :param desired_frequency: number of frames per second generated by splitter, if N
    :param output_folder: location to save new images
    :param save_raw_frames: save frames in output folder
    :return: None
    """
    try:
        capture = cv2.VideoCapture(video_path)
    except:
        print('No video for a given path.')

    fps = capture.get(cv2.CAP_PROP_FPS)

    if not desired_frequency:
        # if desired frequency is not provided, original video fps is chosen
        desired_frequency = fps
    if (fps / desired_frequency) < 1:
        raise Exception("""Desired fps is bigger than initial fps. Please change desired_frequency parameter to smaller
                        value""")

    output_path = Path(output_folder)
    if not output_path.exists() and save_raw_frames:
        output_path.mkdir(parents=True)

    frames: Dict[str, np.ndarray] = {}
    frame_number = 0
    iterator = math.floor(fps / desired_frequency)

    success, frame = capture.read()
    while success:
        if iterator == math.floor(fps / desired_frequency):
            if save_raw_frames:
                cv2.imwrite(f'{output_folder}/frame_{frame_number}.jpg', frame)
            frames[frame_number] = frame
            frame_number += 1
            iterator = 0
        else:
            iterator += 1
        success, frame = capture.read()
    return frames


def mask_defined_color_pixels(image: np.ndarray,
                              convert_format: str,
                              min_range: Tuple = (36, 25, 25),
                              max_range: Tuple = (70, 255, 255)
                              ) -> np.ndarray:
    """
    Process image (loaded as opencv np.array) to get only green regions
    Following bounds work for colors in hsv:
    green (HSV): (36, 25, 25) - (70, 255, 255)
    white (HLS): (0, 250, 0) - (255, 255, 255)
    white
    :param image: image as a np.ndarray following cv2 convention
    :param min_range: minimum value of a pixel to be classified as green (in HSV scale)
    :param max_range: maximum value of a pixel to be classified as green (in HSV scale)
    :param convert_format: what format should BGR be transformed into (possible: HSV, HSL)
    :return: grayscale image with blue pixels indicating green pixels and black pixels rest
    """
    if convert_format not in ('HSV', 'HLS'):
        raise Exception('convert format incorrectly defined')
    if convert_format == 'HSV':
        converted = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    elif convert_format == 'HLS':
        converted = cv2.cvtColor(image, cv2.COLOR_BGR2HLS)

    mask = cv2.inRange(converted, min_range, max_range)

    im_gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    im_gray[mask > 0] = 255
    im_gray[mask == 0] = 0
    return im_gray


def write_list_to_txt(elements: list,
                      output_path: str) -> None:
    """
    Write list to txt file (each element is put in next line)
    """
    with open(output_path, 'w') as f:
        for element in elements:
            f.write(f'{element}\n')


def convert_numpy_to_bitmask(array: np.ndarray) -> np.ndarray:
    """
    Convert image into bit array, where 1 indicates pixels with non-zero values
    :param array: numpy image, either grayscale or coloured
    :return: bit-mask array
    """
    assert isinstance(array, np.ndarray)
    if len(array.shape) == 3:
        return np.any(array > 0, axis=2).astype(np.int)
    elif len(array.shape) == 2:
        return (array > 0).astype(np.int)


def show_save_image_with_lines(img_array: np.ndarray,
                               lines: dict,
                               save_fig_path: Optional[str],
                               fig_size: tuple = (12, 7),
                               color: str = 'royalblue'
                               ):
    """
    Show image with predicted lines on it.
    If save_fig provided image is saved in some location
    """
    rgb = img_array[:, :, ::-1].copy()  # convert image from bgr to rgb

    fig = plt.figure(frameon=False)
    fig.set_size_inches(12, 7)

    ax = plt.Axes(fig, [0., 0., 1., 1.])
    ax.set_axis_off()
    fig.add_axes(ax)
    ax.imshow(rgb, aspect='auto')
    for line_name, coords in lines.items():
        plt.plot([coords[0][0], coords[1][0]], [coords[0][1], coords[1][1]], linewidth=3, color=color)
    if save_fig_path:
        fig.savefig(save_fig_path)


def show_save_objects_with_bboxes(img_array: np.ndarray,
                                  objects: dict,
                                  save_fig_path: Optional[str],
                                  fig_size: tuple = (12, 7),
                                  color: str = 'royalblue'
                                  ):

    rgb = img_array[:, :, ::-1].copy()  # convert image from bgr to rgb

    fig = plt.figure(frameon=False)
    fig.set_size_inches(12, 7)

    ax = plt.Axes(fig, [0., 0., 1., 1.])
    ax.set_axis_off()
    fig.add_axes(ax)
    ax.imshow(rgb, aspect='auto')
    rectangles = [Rectangle(xy=(object_dict['x_top_left'], object_dict['y_bottom_right']),
                            width=(object_dict['x_bottom_right'] - object_dict['x_top_left']),
                            height=(object_dict['y_top_left'] - object_dict['y_bottom_right']))
                  for object_dict in objects.values()]
    pc = PatchCollection(rectangles, facecolor=color, alpha=0.2, edgecolor=color)
    ax.add_collection(pc)
    if save_fig_path:
        fig.savefig(save_fig_path)
